WHY DOES REACT NEED A ROOT ELEMENT?
SInce React is all JS, it needs an element where it can render out its own DOM tree
https://www.testdome.com/questions?visibility=3&skillId=304
https://javascript.info/

splitwise ap designing
uber app designing

GraphQL
https://github.com/StephenGrider/GraphQLCasts

Udemy
Username - 

Password - rain@1234

React interview projects
"Comments  And Reply" - https://github.com/hugebelieve/CodingQuestions/tree/master/public/inteview
"ToDo List" - https://github.com/hugebelieve/CodingQuestions/tree/master/public/inteview
"Restaurant Search" -https://github.com/hugebelieve/CodingQuestions/tree/master/public/inteview

Redux projects-https://react.rocks/tag/Redux
Drag and drop projects-https://react.rocks/tag/Drag_Drop
React-https://react.rocks/tag/Beautiful
https://www.golangprograms.com/react-js-blog-crud-operation.html
https://codesource.io/build-simple-blog-using-axios-with-react/

Why do you have to bind this in react?
When we bind the this of the event handler to the component instance in the constructor, we can pass it as a callback without worrying about it losing its context. 
Arrow functions are exempt from this behavior because they use lexical this binding which automatically binds them to the scope they are defined in.

Drawbacks of ReactJS:
Learning curve. Being not full-featured framework it is requered in-depth knowledge for integration user interface free library into MVC framework.
View-orientedness is one of the cons of ReactJS. It should be found 'Model' and 'Controller' to resolve 'View' problem.
Not using isomorphic approach to exploit application leads to search engines indexing problems.
Lots of developers dislike JSX React’s documentation, manuals are difficult for newcomers’ understanding.
React’s large size library.

Kubernetes
https://d3jb1lt6v0nddd.cloudfront.net/udemy/Learn+DevOps+-+Kubernetes.pdf   https://github.com/wardviaene/kubernetes-course
udemy free account
username/password - accounts@goodworklabs.com/
Accounts@123

selectors vs elements, selectors r class and id while elements r <p>,<div>,<span>

componentWillUnmount which gets called before the component is removed from the DOM. 
This method can be beneficial when needing to perform clean up operations, f.e. removing any timers defined in componentDidMount.

to make a const obj immutable, we need to use freeze keyowrd
const frozen = Object.freeze(['Ice', 'Icicle', 'Ice cube'])
frozen.push('Water')
// Uncaught TypeError: Can't add property 3, object is not extensible


what is server stubs
A stub in distributed computing is a piece of code that converts parameters passed between client and server during a remote procedure call (RPC). 
The main idea of an RPC is to allow a local computer (client) to remotely call procedures on a different computer (server).

GRPC
In gRPC a client application can directly call methods on a server application on a different machine as if it was a local object,
 making it easier for you to create distributed applications and services. As in many RPC systems, gRPC is based around the idea of defining a service, 
 specifying the methods that can be called remotely with their parameters and return types. On the server side,
 the server implements this interface and runs a gRPC server to handle client calls.
 On the client side, the client has a stub (referred to as just a client in some languages) that provides the same methods as the server.
 
 Advantages: used for streaming data, bidirection data flow, fast, grpx code can b generated for any language so microservices cn be created for any languageS

gRPC lets you define four kinds of service method:

Unary RPCs where the client sends a single request to the server and gets a single response back, just like a normal function call.
rpc SayHello(HelloRequest) returns (HelloResponse) {
}
Server streaming RPCs where the client sends a request to the server and gets a stream to read a sequence of messages back.
 The client reads from the returned stream until there are no more messages. gRPC guarantees message ordering within an individual RPC call.
rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse) {
}
Client streaming RPCs where the client writes a sequence of messages and sends them to the server, again using a provided stream. 
Once the client has finished writing the messages, it waits for the server to read them and return its response. 
Again gRPC guarantees message ordering within an individual RPC call.
rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse) {
}
Bidirectional streaming RPCs where both sides send a sequence of messages using a read-write stream. 
The two streams operate independently, so clients and servers can read and write in whatever order they like: for example,
 the server could wait to receive all the client messages before writing its responses, or it could alternately read a message then write a message, 
 or some other combination of reads and writes. The order of messages in each stream is preserved.
rpc BidiHello(stream HelloRequest) returns (stream HelloResponse) {
}

Protocol Buffers in GRPC- they r used to define the messages(data, requests and response), service name and endpoints.
Efficeincy of protocol buffrs over grpc:
1. payload size is lesser thn json payload size
2. faster communication
3. 

memoization- another way specially for functional components to stop unnecessary re-rendering when the state hasn't changed.

React Memoization: to avoid unnecessary re rendering if prop== prev prop in functional components
import React from "react";

export default React.memo(props => {
  console.log("val =", props.val);
  return <div>{props.val}</div>;
});

import React, { Component } from "react";
import FunctionalComp from "./compoments/functionalComp";

import "./App.css";
import functionalComp from "./compoments/functionalComp";

class App extends Component {
  state = {
    val: 1
  };

  componentDidMount() {
    setInterval(() => {
      this.setState({ val: 1 }); //coz of this every1 sec, it will try to setState but memo prevents unecessary re rendering.
    }, 3000);
  }
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <FunctionalComp val={this.state.val} />
        </header>
      </div>
    );
  }
}

export default App;


align-items vs align-content in flex?
The align-items property of flex-box aligns the items inside a flex container along the cross axis just like justify-content does along the main axis.
But align-content is for multi line flexible boxes. It has no effect when items are in a single line. It aligns the whole structure according to its value.

The React docs say that you can use props.children on components that represent ‘generic boxes’ and that don’t know their children ahead of time. 
For me, that didn’t really clear things up. I’m sure for some, that definition makes perfect sense but it didn’t for me.

My simple explanation of what this.props.children does is that it is used to display whatever you include between the opening and closing tags when 
invoking a component.
eg:                                                    
const Picture = (props) => {                  //App.js   
  return (                                      render () {
    <div>                                           <div className='container'>
      <img src={props.src}/>                         <Picture key={picture.id} src={picture.src}>
      {props.children}                                  //what is placed here is passed as props.children  
    </div>                                            </Picture>
  )                                                 </div> )}
} 
this component contains an <img> that is receiving some props and then it is displaying {props.children}.
Whenever this component is invoked {props.children} will also be displayed and this is just a reference to 
what is between the opening and closing tags of the component.

Instead of invoking the component with a self-closing tag <Picture /> if you invoke it will full opening and closing tags <Picture> </Picture> 
you can then place more code between it.
This de-couples the <Picture> component from its content and makes it more reusable.

Grid vs flex?
Grid is Container-Based, Flexbox is Content-Based
Grid Has a “Gap” Property, Flexbox Doesn’t
Flexbox is One Dimensional, Grid is Two Dimensional

A pseudo-class filters existing elements.
a:link means all <a>s that are :link.

A pseudo-element is a new fake element.
div::after means non-existing elements after <div>s.
input[type="email"].big-dog::placeholder {
  color: orange;
}

funtional components in react can't have state, u need to use hooks for tht

What is NPM and Yarn?
Both NPM and Yarn are both package managers. Package Managers is essentially a way to automate the process of
 installing, upgrading, configuring or removing software.
 Yarn is fast as Yarn installs multiple packages at once compared to NPM which installs one at a time.
 Yarn is secure too only installs from your yarn.lock or package.json files. 
 Yarn.lock ensures that the same package is installed throughout all devices,
 this reduces the possibility of bugs from having different versions installed. 
 
 Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array
 to give the elements a stable identity:
 How to create unique keys for React elements?
 There are many ways in which you can create unique keys, the simplest method is to use the index when iterating arrays.
 Other ways:
 You can create a function to generate unique keys/ids/numbers/strings and use that
You can make use of existing npm packages like uuid, uniqid, etc or use random

getDerivedStateFromProps is called after props change and after setState
constructor(props) {
    super(props);
    this.state = {
        expanded: props.expanded,
        ownUpdate: false
    }
}

static getDerivedStateFromProps(props, state) {
    if (state.ownUpdate) {
        return {
            expanded: state.expanded,
            ownUpdate: false
        };
    } else if (props.expanded !== state.expanded) {
        return {
            expanded: props.expanded
        };
    }
    return null;
}

toggle() {
    this.props.onAftePress(this.state.expanded, this.props.index);
    this.setState({
        expanded: !this.state.expanded,
        ownUpdate: true
    })
}

 shallow comparison is when the properties of the objects being compared is done using "===" or strict equality and will not conduct comparisons deeper into the properties. for e.g.
 const user = this.state.user;
user.name = "Jane";

console.log(user === this.state.user); // true
 When comparing objects, it does not compare their's attributes - only their references are compared
 
 Calling setState in render causes infinite loops
 Calling setState() here makes your component a contender for producing infinite loops.

The render() function should be pure, meaning that it does not modify component state, it returns the same result each time it’s invoked, 
and it does not directly interact with the browser.
setState() is async, meaning there is no guarantee that the state has been updated if we try to access the value immediately
You can only change state with setState and React will react to the change

SetState can take upto 2 values. 1-state updater and 2nd-callback
eg:this.setState({[name]:value},()=>{this.logFields()});

setting state in componentWillUnmount shd not be done coz it can lead to memory leaks and lead to slowness of ur React App
The worst case would be to miss removing event listeners and especially intervals. Imagine an interval every second updating the local state of a component
 even though the component got unmounted. If you miss to remove this interval, you may experience how it slows down your application.

Middleware:eg: redux-thunk and redux-logger, saga
In thunk instead of dispatching actions directly we wrap it inside a function/action-creator and then we call that function to return 
that action.

Updating Nested Objects in redux 
The key to updating nested data is that every level of nesting must be copied and updated appropriately.
Correct Approach: Copying All Levels of Nested Data
function updateVeryNestedField(state, action) {
  return {
    ...state,
    first: {
      ...state.first,
      second: {
        ...state.first.second,
        [action.someId]: {
          ...state.first.second[action.someId],
          fourth: action.someValue
        }
      }
    }
  }
}
 Or third party libraries like Immer or redux toolkit can also b used
 Our Redux Toolkit package includes a createReducer utility that uses Immer internally. Because of this, 
 you can write reducers that appear to "mutate" state, but the updates are actually applied immutably.
 import { createReducer } from '@reduxjs/toolkit'

const initialState = {
  first: {
    second: {
      id1: { fourth: 'a' },
      id2: { fourth: 'b' }
    }
  }
}

const reducer = createReducer(initialState, {
  UPDATE_ITEM: (state, action) => {
    state.first.second[action.someId].fourth = action.someValue
  }
})
this only works correctly if you are using the "magic" createReducer function from
 Redux Toolkit that wraps this reducer in Immer's produce function.
 
promises vs callbacks?
Javascript has two major ways of dealing with asynchronous tasks - callbacks and Promises.
aslo async/await can also be used.

what does serviceworker do? what is App cell? what is a PWA(Progressive web apps) eg: fipkart
serviceworker- it is a script that caches all the resources needed on 1st render for page, manages cache and 
helps u decide when to hit cache and when to hit web server network.
These also can handle push notifications/messages. when a mesage comes in, it wakes up the service worker and then using its onpush handler
to show the notification.
To check if browser supports service worker, put a cond. in service worker file like if('serviceworker' in navigator), then register the file



React.Fragments vs div for returning multiple children?
Fragments let you group a list of children without adding extra nodes to the DOM.

IMP****each return statement must have only one div
Diff between State and Props?
State is a way for a component to store an internal state and it is perfect for when u want to store a field value or perhaps toggle a modal.
Props is what is being passed to component from the parent  element, this is how u most commonly work with data in react.

What is context??
Context is globally available prop that should only be used on occasions when u need something that is going to b everywhere in the applications 
perhaps for translating texts or something like that

Here’s the syntax for the useEffect() hook:

const App = () => {
 const [joke, setJoke] = useState("Please wait...");
useEffect(() => {
   axios("https://icanhazdadjoke.com", {
     headers: {
       "Accept": "application/json",
       "User-Agent": "Zeolearn"
     }
   }).then(res => setJoke(res.data.joke));
 },[]);
  return (<div className="joke">{joke}</div>);
}
//we provide this empty [] inorder to avoids unncessary rerenders, alo note api call will be made if we write something inside this [],
 and on change of tht state, api call happens 

Order of lifecycle methods
During Inital render:
constructor->ComponentWillMount-->render-->ComponentDidMount

During re render

where re rendering is not required
1.Pure Components 2.shouldComponentUpdate
shouldComponentUpdate has 2 argumens nextProp and nextState
shouldComponentUpdate(nextProp,nextState){
return (this.state.val===nextState.val?false:true)

logging out users from multiple tabs in React??
1. You can attach a listener to a storage event (fired when storage item is changed) and send a logout-event signal.

localStorage.setItem('logout-event', 'logout' + Math.random());
Every other tab will get it with a listener.

window.addEventListener('storage', function(event){
    if (event.key == 'logout-event') { 
        // ..
    }
});
We can add an event listener for our storage and check if the token becomes null then,
 we’ll dispatch a logout action to logout the user from all the open tabs.

2. auto-refresh, for example every 60 seconds, just to be sure it works when tabs are opened at different computers.
 If localStorage doesn't work (very old browsers), auto-refresh every 3 seconds.
 To each page of your site, you will have to add a javascript code which will periodically (say every second) check login status 
 by sending asynchronous requests to your server.

 setInterval(check_login_status(), 1000);  

And if it recieves a not logged in response, it will have to redirect him to logged out page

 window.open('/logged-out', '_self'); 

Higher Order Components??
a component tht returns another component.
In this we dont change the functionality of component but minor things like injecting new props, building custom errors and setting defaults.

Syntax of hoc
const EnhancedComponent = higherOrderComponent(WrappedComponent, data we r interested in);

eg:
const CommentListWithSubscription = withSubscription(
  CommentList,
  (DataSource) => DataSource.getComments()
);
//When CommentListWithSubscription and BlogPostWithSubscription are rendered, CommentList and BlogPost will be passed a data prop
// with the most current data retrieved from DataSource:

const BlogPostWithSubscription = withSubscription(      //BlogPostWithSubscription is the enhanced component, withSubscription is the hoc name, 
  BlogPost,                                              //BlogPost is wrapped component and
  (DataSource, props) => DataSource.getBlogPost(props.id)  //(DataSource, props) is the repetitive data tht we want to include in hoc
);
// This function takes a component...
function withSubscription(WrappedComponent, selectData) {
  // ...and returns another component...
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.handleChange = this.handleChange.bind(this);
      this.state = {
        data: selectData(DataSource, props)
      };
    }

    componentDidMount() {
      // ... that takes care of the subscription...
      DataSource.addChangeListener(this.handleChange);
    }

    componentWillUnmount() {
      DataSource.removeChangeListener(this.handleChange);
    }

    handleChange() {
      this.setState({
        data: selectData(DataSource, this.props)
      });
    }

    render() {
      // ... and renders the wrapped component with the fresh data!
      // Notice that we pass through any additional props
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
  };
}
//a HOC doesn’t modify the input component, nor does it use inheritance to copy its behavior.
 Rather, a HOC composes the original component by wrapping it in a container component. A HOC is a pure function with zero side-effects.


Pure Components: where re rendering is not required
import {PureComponent} from 'react';
class App extends Pure.Component{
}
It does a shallow compare of objects between previous state and current state
If both same nothing changes

What are propTypes and what are the benefits/drawbacks of using them??
Prop Types is a way fro u to know what types a component is expecting.
They r great to know when u want to know what a component needs to work

they often become legacy documentation and people forget to keep them updated or they put '.required' on the wrong things and often
 i c people use '.object' instead of 'shapeOf'.


Which lifecycle is the most common from ur perspective?? 
'componentWillMount and componentDidMount and componentWillRecieveProps.It is often when i find that i need to do something 
when my component is getting a new state

When do use a Pure component and when a Class Component?
I favour using PureComponents over Class Component if i m not storing a state or using a lifecycle event. Also for optimising performance

How React Rendering works?
React listens for DOM Updates and rerenders the DOM tree on every change but it can do this very quickly coz of a 
diffing algorithm which checks if there is a change in state
means that React checks if there is a 
change in the Compoonent and only rerenders if there is 1.

We create Ref's in a constructor, assign them to instance variables ,then pass it to a particular JSX element as props
constructor(props){
super(props);
this.imageRef=React.createRef();
}
we pass this to jsx 
example: <img ref={this.imageRef} alt="" src="" />

Using ref for form validation

class App extends React.Component {
  constructor(props) {
    super(props);

    this.username = React.createRef();
    this.password = React.createRef();
    this.state = {
      errors: []
    };
  }

  handleSubmit = (event) => {
    event.preventDefault();
    const username = this.username.current.value;
    const password = this.password.current.value;
    const errors = this.handleValidation(username, password);

    if (errors.length > 0) {
      this.setState({ errors });
      return;
    }
    // submit data
  };

  handleValidation = (username, password) => {
    const errors = [];
    if (username.length === 0) {
      errors.push("Username cannot be empty");
    }

    if (password.length < 6) {
      errors.push("Password should be at least 6 characters long");
    }

    return errors;
  };

  render() {
    const { errors } = this.state;
    return (
      <div>
        <h1>React Ref Example</h1>
        <form onSubmit={this.handleSubmit}>
          {errors.map(error => <p key={error}>{error}</p>)}
          <div>
            <label>Username:</label>
            <input type="text" ref={this.username} />
          </div>
          <div>
            <label>Password:</label>
            <input type="text" ref={this.password} />
          </div>
          <div>
            <button>Submit</button>
          </div>
        </form>
      </div>
    );
  }
}


ReactDOM.render(<App />, document.getElementById("root"));

why is redux state immutable,?
Redux was originally invented to demonstrate the idea of "time-travel debugging" - being able to step back and forth through the history of 
dispatched actions, and see what the UI looks like at each step. Another aspect is being able to live-edit the code, reload it, and see what the output looks
 like given the new reducer logic.

In order to be able to properly step back and forth between states, we need to make sure that reducer functions have no side effects. 
That means data updates need to be applied immutably. If a reducer function actually directly modifies its data, then stepping back and forth between states will cause 
the application to behave in an unexpected fashion, and the debugging effort will be wasted.

Also, the React-Redux library relies on shallow equality checks to see if the incoming data for a component has changed.
 If the data references are the same, then the wrapper components generated by connect assume that the data has not changed,
 and that the component does not need to re-render. Immutable data updates means that new object references are created,
 and thus connect will see that the data has changed and the UI needs to update.	

===============================================================================================================================
Controlled and Uncontrolled components
A Controlled Component is one that takes its current value through props and notifies changes through callbacks like onChange.
 A parent component "controls" it by handling the callback and managing its own state and passing the new values as props to 
 the controlled component.
 You could also call this a "dumb component".
 
A Uncontrolled Component is one that stores its own state internally, and you query the DOM using a ref to find its current 
value when you need it. 
This is a bit more like traditional HTML.

In a controlled component, form data is handled by a React component. The alternative is uncontrolled components, where form data is handled by the DOM itself.
To write an uncontrolled component, instead of writing an event handler for every state update, you can use a ref to get form values from the DOM.

how to get object from an array
event bubbling and event capture(in modern browsers always capturing happens first)

To use event capturing use "true" in the event listenerf

How to stop event bubbling -> event.stopPropagation()
inline, block and inline-block diff? -> the major difference is that inline-block allows to set a width and height on the element.
 Also, with display: inline, top and bottom margins & paddings are not respected, and with display: inline-block they are.
 
height of span tag inside a anchor tag??
how to disable anchor tags-event.preventDefault()
Diff between a map and filter?
how to get all values inside an obj??
So map returns the same number of elements as the original, but the element value will be transformed in some way and filter will return the same or less number of elements 
than the original but not change the original elements’ values.
access a child state from parent??- using ref
whats does babel and webpack do??

Pure / Stateless Components
In react when setState is called , rerendering occurs, this is blind as it doesn't check whether state has chaged or not.
So sometimes its unnecessary to rerender.So to avoid that
Does a shallow compare between previous and next state

Data Types in JS
Number, String, boolean, null, undefined, object, symbol

Primitive vs Non-Primitive data types
Data types that are known as primitive values in JavaScript are numbers, strings, boolean, null, undefined. 
Objects such as functions and arrays are referred to as non-primitive values.

The fundamental difference between primitives and non-primitives is that primitives are immutable and non-primitives are mutable.

ES6 vs TypeScript
There is no difference in both of them. Everything you write in ES6 is supported by Typescript.

Typescript is an extension of ES6. Some features that are additionally included in Typescript are:

1. Type Annotations 
eg: name: String = ‘xyz’
 number: Number = ‘123’;
2. Interfaces
3. Enums
4. Mixins 
and many more…

Now your browser is not yet advanced to understand Typescript, so typescript’s compiler converts your code to plain js so that browser can understand it.
TypeScript only support features are generics and type annotations, Interfaces, Enums, Readonly properties and Mixins
Enums are a new data type supported in Javascript
here are three types of enums:

Numeric enum:they store string values as numbers.
String enum:the enum values are initialized with string values rather than numeric values.
Heterogeneous enum: contain both string and numeric values.

Mixins
[A mixin is] a function that

1. takes a constructor,
2. declares a class that extends that constructor,
3. adds members to that new class, and
4. returns the class itself.

ES6 new features
ES6 Features: handling asynchronous functions

Arrows: These are a function which is described by the ‘=>’ syntax
Objects: Object literals are used to support the prototype assignments.
Classes: ES6 classes can be easily implemented over the prototype based object oriented pattern
Destructing: It allows binding pattern which is based primarily on the pattern matching.
String interpolation using Template Literals
Default
Spread Opertor
Module Loaders
Weak set
Map
New Library
Promises
Proxies

uses of arrow functions?
In classic function expressions, the this keyword is bound to different values based on the context in which it is called. With arrow functions however, 
this is lexically bound. It means that it uses this from the code that contains the arrow function.

 We’ve seen how arrow functions don’t bind a this and they just use the value of this in their scope. 
 Arrow functions also don’t bind an arguments object. With function expressions, you can do this
 
 Resolving multiple promises at once??
 Promise.all() is useful anytime you have more than one promise and your code wants to know when all the operations that those promises represent 
 have finished successfully. 
 It does not matter what the individual async operations are. 
 If they are async, are represented by promises and your code wants to know when they have all completed, then Promise.all() is built to do exactly that.
 
 Promise.race(): used when passing multiple promises and i will be satisfied as soon as any 1 promise gets fulfilled, 
 used when we r getting same data from all promises, o as sson as 1 gets fulfilled, we r satisfied. 

For example, suppose you need to gather information from three separate remote API calls and when you have the results from all three API calls,
 you then need to run some further code using all three results. That situation would be perfect for Promise.all(). You could so something like this:
 Promise.all([apiRequest(...), apiRequest(...), apiRequest(...)]).then(function(results) {
    // API results in the results array here
    // processing can continue using the results of all three API requests
}, function(err) {
    // an error occurred, process the error here
});

WEBHOOKS???
There are two ways your apps can communicate with each other to share information: polling and webhooks.
Webhooks are automated messages sent from apps when something happens.
 They have a message—or payload—and are sent to a unique URL—essentially the app's phone number or address.
 Example: They're much like SMS notifications. Say your bank sends you an SMS when you make a new purchase.
 You already told the bank your phone number, so they knew where to send the message. 
 They type out "You just spent $10 at NewStore" and send it to your phone number +1-234-567-8900.
 Something happened at your bank, and you got a message about it. All is well.
 
 HTML 5 webWorkers
 WHEN U MAKE A ASYNC CALL or when u click a button/when u execyte a big loop, during tht call execution it might take some time for the call to get complete.
 During tht time u wont b able to do anything else
 So what a WebWorker does it takes the async call to backend so tht rest of the functionality can be executed meanwhile.
 
 When executing scripts in an HTML page, the page becomes unresponsive until the script is finished.
A web worker is a JavaScript that runs in the background, independently of other scripts, without affecting the performance of the page.
 You can continue to do whatever you want: clicking, selecting things, etc., while the web worker runs in the background.
 We can terminate the web worker using the "terminate" keyword and reuse it by setting it to "undefined"
 
 Javascript call stack
 JavaScript has a single call stack in which it keeps track of what function we’re currently executing and what function is to be executed after that.
 But first — what’s a stack? A stack is an array-like data structure but with some limitations — y
 ou can only add items to the back and only remove the last item. Another example is a pile of plates — you put them on top of each other and at any time 
 you can only remove the top one.

When you’re about to execute a function it is added on the call stack. 
Then if that function calls another function — the other function will be on top of the first one in the call stack.
 When you get an error in the console you get a long message that shows you the path of execution — this is what the stack looked in that exact moment. 
 But what if we make a request or put a timeout on something? 
 In theory that should freeze the entire browser until it is executed so the call stack can continue? In practice however, 
 you know that this doesn’t happen — because of the Event Table and Event Queue.
 
 The Event Table & Event Queue
Every time you call a setTimeout function or you do some async operation — it is added to the Event Table. 
This is a data structure which knows that a certain function should be triggered after a certain event. 
Once that event occurs (timeout, click, mouse move) it sends a notice. 
Bear in mind that the Event Table does not execute functions and does not add them to the call stack on it’s own.
 It’s sole purpose is to keep track of events and send them to the Event Queue.

The Event Queue is a data structure similar to the stack — again you add items to the back but can only remove them from the front. 
It kind of stores the correct order in which the functions should be executed. It receives the function calls from the Event Table,
 but it needs to somehow send them to the Call Stack? This is where the Event Loop comes in.
 
Event Loop
We’ve finally reached the infamous Event Loop. This is a constantly running process that checks if the call stack is empty. 
Imagine it like a clock and every time it ticks it looks at the Call Stack and if it is empty it looks into the Event Queue. 
If there is something in the event queue that is waiting it is moved to the call stack. If not, then nothing happens. 

Another interesting example of the Event Loop’s behavior is recursion. Have you ever seen the stack overflow error message? 
You sometimes get that when you make an infinite recursion but sometimes you actually have a big number of recursive calls that you want to make.
There’s a simple yet hacky workaround which will allow you to retain your code structure and still make an absurd amount of calls — 
wrap your recursion calls in setTimeout.

Super() vs super(props)?
If you want to use this.props inside constructor, you need to pass it in super,
otherwise it’s okay to not pass props to super as we see that irrespective of passing it to super,
this.props is available inside render function.

Conflicts when using D3.js with React.js??
If it’s React: then React will create, remove and update DOM nodes. All of the d3 selectAll/data patterns will be replaced by the use of React props.
 There’s more to d3js than DOM manipulation though: color palettes, data scales, generating paths etc, 
 all of which you can use even for nodes not created through d3js. This approach is more performant and more React-y but makes transitions, 
 one of the most compelling aspect of d3js, harder to implement. You’d have to rely on componentDidUpdate / componentWillUnmount methods. 
 Note that this is pretty similar to working with canvas and d3js.
 
he way most people use D3 with React is to use React to build the structure of the application, and to render traditional HTML elements, 
and then when it comes to the data visualization section,
 they pass a DOM container (typically an <svg>) over to D3 and use D3 to create and destroy and update elements.
 The main difficulty is that you need to create functions in various React lifecycle events to make sure your viz updates.
 
 import React, { Component } from 'react'
import './App.css'
import { scaleLinear } from 'd3-scale’
import { max } from 'd3-array'
import { select } from 'd3-selection'
class BarChart extends Component {
   constructor(props){
      super(props)
      this.createBarChart = this.createBarChart.bind(this)
   }
   componentDidMount() {
      this.createBarChart()
   }
   componentDidUpdate() {
      this.createBarChart()
   }
   createBarChart() {
      const node = this.node
      const dataMax = max(this.props.data)
      const yScale = scaleLinear()
         .domain([0, dataMax])
         .range([0, this.props.size[1]])
   select(node)
      .selectAll('rect')
      .data(this.props.data)
      .enter()
      .append('rect')
   
   select(node)
      .selectAll('rect')
      .data(this.props.data)
      .exit()
      .remove()
   
   select(node)
      .selectAll('rect')
      .data(this.props.data)
      .style('fill', '#fe9922')
      .attr('x', (d,i) => i * 25)
      .attr('y', d => this.props.size[1] — yScale(d))
      .attr('height', d => yScale(d))
      .attr('width', 25)
   }
render() {
      return <svg ref={node => this.node = node}
      width={500} height={500}>
      </svg>
   }
}
export default BarChartcbv
 
 
 
 Grid system
display:grid;
grid-template-rows: 300px 100px; height of 1st row becomes 300px, 2nd row as 100px
grid-template-columns: 100px 200px 300px; width of 1st column is 100, 2nd has 200 and 3rd has 300
grid-column-gap: 20px; grid-row-gap: 20px;    introduces gaps beteen rows and columns
grid-gap:20px; for both rows and columns

grid-template-columns:repeat(3,200px); 3 is no of times u wanna repeat the columns and 200 px is the size
This is non-responsive as we r using pixel
So we use fractional unit i.e. fractional

grid-template-columns:repeat(auto-fit,minmax(200px,1fr));

grid-template-columns:1fr 1fr 1fr; creating 3 columns and each takes 1 fraction of a space. This is responsive
similarly,
grid-template-columns:1fr 3fr 1fr; the middle column takes 3 frction of a spce available 

.item5{
  grid-column-start:1;//starts at its own line 1
  grid-column-end:3;//ends at it own line3
}	

In Bootstrap, the "row" class is used mainly to hold columns in it. Bootstrap divides each row into a grid of 12 virtual columns.

Javascript hoisting
When a variable is declared b4 getting initialised.

var y=2;
var x= function(){
 console.log(y); //undefined
 var y=1;
}

react mostly is client side rendering but can be run both on client side as well as server side rendering.
React allows developers to create large web-applications that use data and can change over time without reloading the page. 
It aims primarily to provide speed, simplicity, and scalability. 

In Client-side rendering, your browser downloads a minimal HTML page. It renders the JavaScript and fills the content into it.

Server-side rendering, on the other hand, renders the React components on the server. The output is HTML content.
Cons of Rendering React on the Server
SSR can improve performance if your application is small. But it can also degrade performance if it is heavy.
It increases response time (and it can be worse if the server is busy).
It increases response size, which means the page takes longer to load.
It increases the complexity of the application.


Context -API
to pass props to deeply nested children

eg: state={
   age:100,
   name:"manas"
}
* to create a context
	const myContext=React.createContext();

to return a parents data to a child we wrap the	context inside a provider 
eg: <myContext.Provider value={{ state:this.state }}> {this.props.children} </myContext.Provider>
And to recieve tht data in child we use Consumer. It always renders a function
eg: <myContext.Consumer>
       {(context)=>( <p>I'm inside the {context}</p> //context contains data stored inside value. 
	   //context.state.age gives us age and context.state.name gives us name..also functions can be passed in provider value
	   )}
	</myContext.Consumer>
	
How to check whteher video is buffering?
You can check the state at any time by looking at two properties, networkState and readyState
if (video.networkState === video.NETWORK_LOADING) {
    // The user agent is actively trying to download data.
}

if (video.readyState < video.HAVE_FUTURE_DATA) {
    // There is not enough data to keep playing from this point
}	
	
	Using async and await
We can make working with promises even simpler with async and await. 
The await keyword resolves the promise and returns the value which we can assign to a variable. 

Why is Lazy Loading (& Suspense) Important
Firstly, bundling involves aligning our code components in progression and putting them in one javascript chunk that it passes to the browser;
 but as our application grows, we notice that bundle gets very cumbersome in size. This can quickly make using your application very hard and
 especially slow.
 With Code splitting, the bundle can be split to smaller chunks where the most important chunk can be loaded first 
 and then every other secondary one lazily loaded.
Also, while building applications we know that as a best practise consideration should be made for users using mobile internet data and 
others with really slow internet connections. We the developers should always be able to control the user experience even during a suspense period
(when the data is still being loaded in the DOM) 
when resources are being loaded to the DOM.


Suspense
Suspense is a component required by the lazy function basically used to wrap lazy components. 
Multiple lazy components can be wrapped with the suspense component.
 It takes a fallback property that accepts the react elements you want to render as the lazy component is being loaded.
	
	const OtherComponent = React.lazy(() => import('./OtherComponent'));
function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}

//To center an element
div.centered {
  position: fixed; /* or absolute */
  top: 50%;
  left: 50%;
  /* bring your own prefixes */
  transform: translate(-50%, -50%);
}

Making a triangle
#triangle {
    width: 0;
    height: 0;
    border-left: 40px solid transparent;
    border-right: 40px solid transparent;
    border-bottom: 80px solid lightblue;
}
Use of meta tag 'viewport' and why we use initial scale =1
<meta name="viewport" content="width=500, initial-scale=1">
For example, if your layout needs at least 500 pixels of width then you can use the following markup. When the screen is more than 500 pixels wide,
 the browser will expand the viewport (rather than zoom in) to fit the screen:
 Other attributes that are available are minimum-scale, maximum-scale, and user-scalable. These properties affect the initial scale and width, as well as limiting changes in zoom level.


How to use bootstrap with 16 or 24 columns??  yes
<div class="col-md-12">

    <div class="col-md-6">
        <div class="col-md-1">nothing</div>
        <div class="col-md-1">nothing</div>
        <div class="col-md-1">nothing</div>
        <div class="col-md-1">nothing</div>
        <div class="col-md-1">nothing</div>
        <div class="col-md-1">nothing</div>
        <div class="col-md-1">nothing</div>
        <div class="col-md-1">nothing</div>
        <div class="col-md-1">nothing</div>
        <div class="col-md-1">nothing</div>
        <div class="col-md-1">nothing</div>
        <div class="col-md-1">nothing</div>
    </div>

    <div class="col-md-6">12 here</div>

</div> 

HTML5 new features	
<section> defines sections of pages.
<header> defines the header of a page.
<footer> defines the footer of a page.
<nav> defines the navigation on a page.
<article> defines the article or primary content on a page.
<aside> defines extra content like a sidebar on a page.
<figure> defines images that annotate an article.	
<progress> indicates the progress of a task towards completion.
async and defer in script tags
<video> – Add video to your web pages with this simple tag.
<audio> – Add sound to your web pages with this simple tag.

	
CSS 3 new features	
Attribute selectors
Matches any element E whose attribute attr starts with the value val. In other words, the val matches the beginning of the attribute value.
E[attr^=val]
eg.          a[href^='http://sales.']{color: teal;}	

Matches any element E whose attribute attr ends in val. In other words, the val matches the end of the attribute value.
E[attr$=val]
eg.          a[href$='.jsp']{color: purple;}

border-radius for rounded corners
Drop Shadows: box-shadow: 2px 5px 0 0 rgba(72,72,72,1);
Text Shadow
Linear Gradients
background: linear-gradient(to right, red , yellow);

Multiple Background Images eg:background-image:
url(firstImage.jpg),
url(secondImage.gif),
url(thirdImage.png);

2 way binding in react- using LinkedStateMixin
var createReactClass = require('create-react-class');

var WithLink = createReactClass({
  mixins: [LinkedStateMixin],
  getInitialState: function() {
    return {message: 'Hello!'};
  },
  render: function() {
    return <input type="text" valueLink={this.linkState('message')} />;
  }
});

Async Cancellation- when we want to cancel all the old api calls which r pending and only want to resolve the latest 1
We use a variable (abortController) that is scoped outside of the function in question. 
That way, no matter how many times the function is called and no matter how many requests are in-flight, 
the only result that will be displayed is the request that was submitted last.

let abortController = new AbortController();

const loadData = async (url) => {
  abortController.abort(); // Cancel the previous request
  abortController = new AbortController();

  try {
    let response = await fetch(url, { signal: abortController.signal });
    let data = await response.json();

    updateUI(data);
  }
  catch (ex) {
    if (ex.name === 'AbortError') {
      return; // Continuation logic has already been skipped, so return normally
    }

    throw ex;
  }
};


Redux Thunk
const loadData = (url) => async (dispatch) => {
  dispatch({ type: 'LOAD_DATA', status: 'pending' });

  let response = await fetch(url);
  let data = response.json();

  dispatch({ type: 'LOAD_DATA', status: 'success', data });
};


box-sizing defines how the width and height gets applied on an element. It can be useful to play with box-sizing if, 
for example, an element needs to take a precise amount of space on a page, with its padding and border included. It can take two possible values:
with content-box the element ends up taller and wider than the specified dimensions because the border and padding fall outside of those dimensions.

content-box: The width & height of the element only include the content.
 In other words, the border, padding and margin aren’t part of the width or height. This is the default value.
 
 border-box: The padding and border are included in the width and height.

FOR 2 WAY BINDING VALUE/valueLink needs to be declared along with onChange

LinkedStateMixin adds a method to your React component called linkState().
 linkState() returns a valueLink object which contains the current value of the React state and a callback to change it.
 valueLink objects can be passed up and down the tree as props, 
 so it’s easy (and explicit) to set up two-way binding between a component deep in the hierarchy and state that lives higher in the hierarchy.
 
 Events in react
 onClick(), onChange, onSubmit
 
 In summary, here’s what happens when you try to update the DOM in React:

The entire virtual DOM gets updated.
The virtual DOM gets compared to what it looked like before you updated it. React figures out which objects have changed.
The changed objects, and the changed objects only, get updated on the real DOM.
Changes on the real DOM cause the screen to change.

Thunk
Thunk middleware allows you to write action creators that return a function instead of an action.
 The thunk can be used to delay the dispatch of an action, or to dispatch only if a certain condition is met. 
The inner function receives the store methods dispatch and getState as parameters.

Can we do a map inside render?? Answer: yes

React Lazy() vs React Loadable?
React Loadable works with server side rendering, while React.lazy only works on the client side. 

SASS (Syntactically Awesome Stylesheets) is a CSS pre-processor that lets you use variables, mathematical operations, mixins, loops, 
functions, imports,and other interesting functionalities that make writing CSS much more powerful.
Advantages of sass
1. Variables- eg: $blue: #004BB4;
h1 {
  font: $ubuntu-font;
  color: $blue;
}

2.It uses nested syntax(nesting)
.navbar {
  font: $ubuntu-font;
  color: $blue;
  li {
    margin-left: 1rem;
    a {
      padding: 5px;
      font-size: 1.5rem;
      span {
        font-weight: 600;
   }}}}
3. mixins- if you have blocks of code repeating in your style sheet more than once.
They return a value or set of values and can take parameters including default values. eg:
@mixin set-font( $family: 'Ubuntu' , $weight: 400 , $style: normal ) {
  font-family: $family , 'Arial', 'Helvetica', sans-serif;
  font-style: $style;
  font-weight: $weight;
}

To use a mixin we use the includes keyword
h1 {
  @include set-font;
  color: $blue;
}

4. importing SCSS/SASS files is really easy: as this doesnt send a http request each time.
he difference between this and the CSS @import rule is that all imported SCSS files will be merged together into a single CSS file, 
so in the end, only a single HTTP call will be requested because you will be serving a unique CSS file to the web server.
@import "source/font-awesome";           
@import "source/slick";                         
@import "framework/bootstrap";  
@import "my-custom-theme";


Dynamic Import for code splitting, loading a component only when called
This props.load returns a promise, which when resolved calls a module

class DynamicImport extends React.Component{
  state={
   component:null
  }
  componentWillMount()  {
    this.props.load() //calls the module, this is a promise once resolved
	 .then((mod)=> this.setState(()=>({
	 component:mod.default
	 })))
  }
  render(){
   return this.props.children(this.state.Component)
  }
}

const Settings=(props)=>(
  <DynamicImport load={()=>import('./Settings')}>
  {(Component)=>Component===null ? <h1>Loading...</h1> : <Component {...props} /> }
  </DynamicImport>  
)

React question to start a timer when hovering over the box and stopping it when u exit the box hover, also a reset button is der to reset the timer
//onMouseEnter
//onMouseLeave

class App extends React.Component {
   constructor(props){
   state={time:0};

   timerIncrease=()=>{
     this.setState({time:this.state.time+1})
   }

   handleHover=()=>{
    this.myInterval=setInterval(this.timerIncrease,1000)
   }

   handleLeave=()=>{
      clearInterval(this.myInterval);
   }

   resetButton=()=>{
     this.setState({time:0})
   }


  render(){
  return (
    <div className="App">
      <div className="hover-box" onMouseLeave={this.handleLeave} onMouseEnter={this.handleHover}>Box on hover</div>
      <p className="hover-timer">{this.state.time} seconds</p>
      <button onClick={this.resetButton} className="hover-reset">Reset</button>
    </div>
  );
}}

const rootElement = document.getElementById("root");
ReactDOM.render(<App />, rootElement);

The findIndex() method returns the index of the first element in an array that pass a test (provided as a function).

The findIndex() method executes the function once for each element present in the array:

If it finds an array element where the function returns a true value, findIndex() returns the index of that array element (and does not check the remaining values)
Otherwise it returns -1

import ReactDOM from "react-dom";
import React, { Component } from "react";

// state data for 3 counters

// Counter Component
class Counter extends Component {
  render() {
    const { counter, onChange } = this.props;
    return (
      <div className="counter">
        <b>{counter.value}</b>
        <div className="counter-controls">
          <button
            className="button is-danger is-small"
            onClick={() => onChange(counter.id, counter.value - 1)}
          >
            -
          </button>
          <button
            className="button is-success is-small"
            onClick={() => onChange(counter.id, counter.value + 1)}
          >
            +
          </button>
        </div>
      </div>
    );
  }
}

class App extends Component {
  constructor(props, context) {
    super(props, context);
    this.state = {
      data: [{ id: 1, value: 0 }, { id: 2, value: 0 }, { id: 3, value: 0 }],
      total: 0
    };
  }
  handleChange = (id, value) => {
    const eleIndex = this.state.data.findIndex(ele => ele.id === id);
    const newArr = [...this.state.data];

    if (value >= 0) newArr[eleIndex].value = value;
    const total = newArr.reduce(
      (acc, element) => (acc = acc + element.value),
      0
    );

    this.setState({ data: [...newArr], total: total });
  };

  render() {
    return (
      <div>
        {this.state.data.map(counter => (
          <Counter
            key={counter.id}
            counter={counter}
            onChange={this.handleChange}
          />
        ))}
        <p>Total : {this.state.total}</p>
      </div>
    );
  }
}

ReactDOM.render(<App />, document.getElementById("root"));




Problem 1
import ReactDOM from 'react-dom';
import React, { Component } from 'react';

// state data for 3 counters
 

// Counter Component
class Counter extends Component {
  render() {
    const { counter ,onIncrement , onDecrement } = this.props;
    return (
      <div className="counter">
        <b>{counter.value}</b>
        <div className="counter-controls">
          <button className="button is-danger is-small" onClick = {() => onDecrement(counter.id)}>-</button>
          <button className="button is-success is-small" onClick ={() => onIncrement(counter.id)}>+</button>
        </div>
      </div>
    );
  }
}

class App extends Component {

  constructor(props, context) {
    super(props, context);
    this.state = {
      data : [
        { id: 1, value: 0 },
        { id: 2, value: 0 },
        { id: 3, value: 0 }
      ],
      total : 0
    }
  }
  handleIncrement = (id) =>{
    const eleIndex = this.state.data.findIndex(ele => ele.id === id );
    const newArr = [...this.state.data];

    newArr[eleIndex].value += 1;
    const total = newArr.reduce((acc , element) => acc= acc+element.value,0)

   this.setState({data : [...newArr] , total : total})
 
  }

  handleDecrement = (id) =>{
    const eleIndex = this.state.data.findIndex(ele => ele.id === id );
    const newArr = [...this.state.data];

    newArr[eleIndex].value -= 1;
    const total = newArr.reduce((acc , element) => acc= acc+element.value,0)

   this.setState({data : [...newArr] , total : total})
  }

  render() {
    return (
      <div>
        {this.state.data.map(counter => (
          <Counter 
            key={counter.id}
            counter={counter}
            onIncrement = {this.handleIncrement}
            onDecrement = {this.handleDecrement}
            />
        ))}
        <p>Total : {this.state.total}</p>
      </div>
    );
  }
}




ReactDOM.render(<App />, document.getElementById('root'));

Autocomplete search bar
$(function() {
    var alreadyFilled = false;
    var states = ['Alabama','Alaska','American Samoa','Arizona','Arkansas','California','Colorado','Connecticut','Delaware','District of Columbia','Federated States of Micronesia','Florida','Georgia','Guam','Hawaii','Idaho','Illinois','Indiana','Iowa','Kansas','Kentucky','Louisiana','Maine','Marshall Islands','Maryland','Massachusetts','Michigan','Minnesota','Mississippi','Missouri','Montana','Nebraska','Nevada','New Hampshire','New Jersey','New Mexico','New York','North Carolina','North Dakota','Northern Mariana Islands','Ohio','Oklahoma','Oregon','Palau','Pennsylvania','Puerto Rico','Rhode Island','South Carolina','South Dakota','Tennessee','Texas','Utah','Vermont','Virgin Island','Virginia','Washington','West Virginia','Wisconsin','Wyoming'];

    function initDialog() {
        clearDialog();
        for (var i = 0; i < states.length; i++) {
            $('.dialog').append('<div>' + states[i] + '</div>');
        }
    }
    function clearDialog() {
        $('.dialog').empty();
    }
    $('.autocomplete input').click(function() {
        if (!alreadyFilled) {
            $('.dialog').addClass('open');
        }

    });
    $('body').on('click', '.dialog > div', function() {
        $('.autocomplete input').val($(this).text()).focus();
        $('.autocomplete .close').addClass('visible');
        alreadyFilled = true;
    });
    $('.autocomplete .close').click(function() {
        alreadyFilled = false;
        $('.dialog').addClass('open');
        $('.autocomplete input').val('').focus();
        $(this).removeClass('visible');
    });

    function match(str) {
        str = str.toLowerCase();
        clearDialog();
        for (var i = 0; i < states.length; i++) {
            if (states[i].toLowerCase().startsWith(str)) {
                $('.dialog').append('<div>' + states[i] + '</div>');
            }
        }
    }
    $('.autocomplete input').on('input', function() {
        $('.dialog').addClass('open');
        alreadyFilled = false;
        match($(this).val());
    });
    $('body').click(function(e) {
        if (!$(e.target).is("input, .close")) {
            $('.dialog').removeClass('open');
        }
    });
    initDialog();
});


Requirements

1. Build an application to show a list of posts. The api to get list of posts is available at https://jsonplaceholder.typicode.com/posts
2. Each post should display the title and description
3. Allow the user to favorite a post and unfavorite a post. The data will remain in the browser and need not be stored on the server.
4. Add the ability to delete a post

List of APIs - 
GET https://jsonplaceholder.typicode.com/posts - to get list of posts 
DELETE https://jsonplaceholder.typicode.com/posts/1 to delete the post

More details at https://jsonplaceholder.typicode.com/guide.html

Program in react js to take an input from user and validate it
import React, { Component } from 'react';
import { render } from 'react-dom';
import './style.css';

class App extends Component {
  render() {
    return (
      <Register />
    );
  }
}

const validEmailRegex = RegExp(/^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i);
const validateForm = (errors) => {
  let valid = true;
  Object.values(errors).forEach(
    (val) => val.length > 0 && (valid = false)
  );
  return valid;
}

class Register extends Component {
  constructor(props) {
    super(props);
    this.state = {
      fullName: null,
      email: null,
      password: null,
      errors: {
        fullName: '',
        email: '',
        password: '',
      }
    };
  }

  handleChange = (event) => {
    event.preventDefault();
    const { name, value } = event.target;
    let errors = this.state.errors;

    switch (name) {
      case 'fullName': 
        errors.fullName = 
          value.length < 5
            ? 'Full Name must be 5 characters long!'
            : '';
        break;
      case 'email': 
        errors.email = 
          validEmailRegex.test(value)
            ? ''
            : 'Email is not valid!';
        break;
      case 'password': 
        errors.password = 
          value.length < 8
            ? 'Password must be 8 characters long!'
            : '';
        break;
      default:
        break;
    }

    this.setState({errors, [name]: value});
  }

  handleSubmit = (event) => {
    event.preventDefault();
    if(validateForm(this.state.errors)) {
      console.info('Valid Form')
    }else{
      console.error('Invalid Form')
    }
  }

  render() {
    const {errors} = this.state;
    return (
      <div className='wrapper'>
        <div className='form-wrapper'>
          <h2>Create Account</h2>
          <form onSubmit={this.handleSubmit} noValidate>
            <div className='fullName'>
              <label htmlFor="fullName">Full Name</label>
              <input type='text' name='fullName' onChange={this.handleChange} noValidate />
              {errors.fullName.length > 0 && 
                <span className='error'>{errors.fullName}</span>}
            </div>
            <div className='email'>
              <label htmlFor="email">Email</label>
              <input type='email' name='email' onChange={this.handleChange} noValidate />
              {errors.email.length > 0 && 
                <span className='error'>{errors.email}</span>}
            </div>
            <div className='password'>
              <label htmlFor="password">Password</label>
              <input type='password' name='password' onChange={this.handleChange} noValidate />
              {errors.password.length > 0 && 
                <span className='error'>{errors.password}</span>}
            </div>
            <div className='info'>
              <small>Password must be eight characters in length.</small>
            </div>
            <div className='submit'>
              <button>Create</button>
            </div>
          </form>
        </div>
      </div>
    );
  }
}

render(<App />, document.getElementById('root'));


make a filter dropdown in react

import React from 'react'

import Spinner from '../../components/Spinner/Spinner'


class Home extends React.Component {
    state = {
        details: [],
        loading: true
    }
    componentDidMount() {
        fetch('https://reqres.in/api/users?delay=3')
            .then(res => {
                return res.json()
            })
            .then(data => {
                this.setState({ details: data.data, loading: false })
            })
            .catch(err => console.log(err))
    }

    changeHandler = (e) => {
        const { details } = this.state;
        if (e.target.value === "firstname") {
            let newArray = details.sort((a, b) => {
                if (a.first_name.toUpperCase() > b.first_name.toUpperCase()) {
                    return 1
                }
                else {
                    return -1
                }
            })
            this.setState({ details: newArray })
        }
        else if (e.target.value === "lastname") {
            let newArray = details.sort((a, b) => {
                if (a.last_name.toUpperCase() > b.last_name.toUpperCase()) {
                    return 1
                }
                else {
                    return -1
                }
            })
            this.setState({ details: newArray })
        }
    }
    render() {

        return (
            <div className="container">
                {this.state.loading ? <Spinner /> :
                    <>
                        <label>Sort By</label>
                        <select onChange={this.changeHandler} >
                            <option value='none'>----------</option>
                            <option value='firstname'>First Name</option>
                            <option value='lastname'>Last Name</option>
                        </select>
                        
                    </>
                }
            </div>
        )
    }
}

export default Home

import React from 'react'

class SomeListComponent extends React.Component {
  constructor(props) {
  super(props);
    this.state = { items: props.items }
  }

  shouldComponentUpdate(nextProps,nextState) {
    return nextProps.items !== this.props.items
  }

  handleClick= (index)=> {
    this.props.onClick(index)
  }

  renderElement= (item, index) =>{
    return <li key={index} onClick={() => this.handleClick(index)}>{item.text}</li>
  }

  render () {
    return (
      <ul style={{ backgroundColor: 'red', height: 100 }}>
        {this.state.items.map((item, i) => this.renderElement(item, i))}
      </ul>
    )
  }
}

export default SomeListComponent
